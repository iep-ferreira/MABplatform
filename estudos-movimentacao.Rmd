---
title: "estudos-movimentacao"
author: "CeMECA"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Pacotes / Dependências

```{r}
#install.packages("landscapeR")
#install.packages("raster")
#install.packages("uuid")
#devtools::install_github("iep-ferreira/biomastats")
#library(biomastats)
library(raster); library(landscapeR); library(sf);
library(mapview); library(ggplot2); library(unmarked); 
library(dplyr)
library(ggspatial)  # Para lidar com rasters e mapas
library(sf)# Para geometria vetorial (círculo)
library(plotly)
library(uuid)
library(readxl)
library(writexl)
library(digest) # para criar hash
library(sp)
```


## Carrega as funções através do código-fonte

```{r}
carrega <- function(){
source("./source-codes/soma.R")
source("./source-codes/land_create.R")
source("./source-codes/animal_mov.R")
#source("./source-codes/update_mov.R")
source("./source-codes/tracks_viewer.R")
source("./source-codes/estima_testes.R")
source("./source-codes/animal_trajectory.R")  
source("./source-codes/xytoij_transform.R")
source("./source-codes/csv_traj_join.R")  
source("./source-codes/record_trajectories.R")  
source("./source-codes/reduce_matrix.R")  
source("./source-codes/get_angle_map.R")
source("./source-codes/vector_field_vis.R")  
source("./source-codes/matrix_expand.R")  
source("./source-codes/plot_animal_path.R")
source("./source-codes/calc_centroid_radius.R")  
source("./source-codes/camera_position.R")    
}
```


 - Visualização do Raster e propriedades

```{r}
mapa <- raster("./pre-processamento/raster.tif")
lado <- dim(mapa)[1]
extent(mapa) <- extent(0, 1833, 0, 1833)
delimitar <- extent(0, 1800, 0, 1800)
mapa_delim <- crop(mapa, delimitar)
#extent(mapa_delim)
plot(mapa_delim)
lado_delim <- dim(mapa_delim)[1]
```


## Mapeamento de preferências para o algoritmo de movimentação

### transforma o mapa de uso e ocupação em uma matriz de pesos

```{r}
lado_delim*28.66 # lado de 52.5 km
# valores do raster e dicionário
valores_antigos <- sort(unique(getValues(mapa_delim)))
tabela_classes <- biomastats::dict_build()
# filtragem e organização das classes na paisagem
tab_sel <- tabela_classes %>% filter(code %in% valores_antigos) %>%
  arrange(match(code, valores_antigos))
# pesos de habitat e movimentação (paisagem toda)
tab_sel$valores_novos <- c(-8, 10, 8, 7, 5, 4, -3, 4, 2, -10, -7, 3, 2, 4, 2, 4)
source("./source-codes/alterar_valores_raster.R")  
pesos_raster <- alterar_valores_raster(mapa_delim, valores_antigos, tab_sel$valores_novos)  
matrix_pesos <- matrix(getValues(pesos_raster), lado_delim, lado_delim, byrow = TRUE)
```

# Redução da dimensionalidade da paisagem

```{r}
M <- matrix_pesos  # M terá dimensão H x W
carrega()
reduction_factor <- 2
M_reduc <- reduce_matrix(M, reduction_factor)
mapview(raster(M_reduc))
```


```{r}
carrega()
# Executando a função
#matrix_theta <- get_angle_map(M_reduc, radius=3) # usei raio 3  
#save(matrix_theta, file = "./pre-processamento/matrix_theta.Rdata")
# Plotar
load("./pre-processamento/matrix_theta.Rdata")
# Gera o hash SHA-256 do arquivo
#hash_value <- digest(file = "./pre-processamento/matrix_theta.Rdata", algo = "sha256")
#print(hash_value)
```


### O campo vetorial em espaço reduzido

```{r}
carrega()
#tiff(width = 1200, height = 1200)
vector_field_vis(M_reduc, theta_matrix = matrix_theta$angle_matrix, norm_matrix = matrix_theta$norm_matrix, reduction_factor = reduction_factor, n_grid = 20, arrow_scale = 1/10)
#dev.off()
```

### Expandir matriz reduzida

Aqui, realiza-se a expansão das matrizes reduzidas, a fim de se obter a dimensão original. A função `matrix_expand` retornar objetos `raster` para o ângulo de movinetação e sua norma. 

```{r}
carrega()
reduction_factor <- 2
matrix_result <- matrix_expand(matrix_theta, reduction_factor)
#plot(raster(matrix_result$norm, xmn=0, xmx=lado_delim, ymn=0, ymx=lado_delim))
```

```{r}
carrega()
rast_theta <- raster(matrix_result$theta, xmn=0, xmx=lado_delim, ymn=0, ymx=lado_delim)
rast_norm <- raster(matrix_result$norm, xmn=0, xmx=lado_delim, ymn=0, ymx=lado_delim)
hash_value <- digest(file = "./pre-processamento/matrix_theta.Rdata", algo = "sha256")
## gravando as simulações
#system.time({
sim <- 10000
for(i in 1:sim){
try({
mov <- animal_mov(n = 1, raster_theta = rast_theta, raster_norm = rast_norm, time = 4, time_adapt = 0, where = "random", landscape_on = TRUE) 
record_trajectories(mov, hash_value)
})
print(i)  
} # end-for
#})
```

```{r}
dir_path = "./data_sim/"
length(list.files(dir_path))
traj <- select_trajectories(dir_path = dir_path, n_sample = 600)
#class(traj)
```

### Visualização das trajetórias percorridas por cada animal / grupo

```{r}
carrega()
# primeira forma
plot_animal_path(trajetory_obj = traj, landscape = mapa_delim, animal = 1:30, weeks = c(1, 2, 3, 4))
# segunda forma 
#plot_animal_path(trajetory_obj = traj, animal = 7, weeks = c(1, 2, 3, 4))
```

### cálculo do raio de dispersão e posição central 

```{r}
result <- calc_centroid_radius(traj, animal = 1:20, weeks = 3:4, ft = 28.8/1000)
# Exibir os resultados
print(result$centroids)    # Tabela com centróides e raios corrigidos pelo fator
print(result$mcp_polygons) # Polígonos mínimos convexos sem fator de escala
print(result$distances) # Os animais andam, em média, 15km por dia
```

## Posição das câmeras e contagens

```{r}
carrega()
camera_resultado <- camera_position(800, 520, 30, pi, pi/2, 15)
```

```{r}
#camera_counts <- function(cam_obj,  traj_data, temp_buffer = 60, ft_m = 28.8){

temp_buffer <- 20
traj_data <- traj
cam_obj <- camera_resultado

xc <- cam_obj$x_center
yc <- cam_obj$y_center
  
traj_within <- point.in.polygon(traj_data$x, traj_data$y, cam_obj$poly_df$x,  cam_obj$poly_df$y)
traj_filtered <- traj_data %>% filter(traj_within == 1)

# aplicando buffer temporal (em minutos)
traj_filtered <- traj_filtered %>%
  group_by(id_numeric) %>%
  arrange(step, .by_group = TRUE) %>% 
  mutate(
    keep = {
      # Vetor lógico para marcar quais linhas serão mantidas
      keep_vec <- logical(n())
      # Variável que guarda o "step" da última detecção
      last_detection_step <- -Inf
      
      for (i in seq_len(n())) {
        # Se o step atual for MAIOR que (última detecção + buffer),
        # então esta linha passa a ser uma nova detecção
        if (step[i] > last_detection_step + temp_buffer) {
          keep_vec[i] <- TRUE
          last_detection_step <- step[i]  # atualiza o último step de detecção
        } else {
          keep_vec[i] <- FALSE
        }
      }
      keep_vec
    }
  ) %>%
  filter(keep) %>%
  ungroup()

traj_filtered$distance <- sqrt( (traj_filtered$x - xc )^2 +  (traj_filtered$y - yc)^2 )
  
#}

life_area_data <- traj_data %>% filter( xc - 200 < x & x < xc + 200 & yc - 200 < y &  yc + 200 > y)

result <- calc_centroid_radius(life_area_data, weeks = 2:4, ft = 28.8/1000)

mapview(result$mcp_polygons) + mapview(camera_resultado$poly_sf) +
  mapview(traj_filtered, xcol = "x", ycol = "y")


```




