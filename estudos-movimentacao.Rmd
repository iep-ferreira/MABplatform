---
title: "estudos-movimentacao"
author: "CeMECA"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Pacotes / Dependências

```{r}
#install.packages("landscapeR")
#install.packages("raster")
#install.packages("uuid")
#devtools::install_github("iep-ferreira/biomastats")
#library(biomastats)
library(raster); library(landscapeR); library(sf);
library(mapview); library(ggplot2); library(unmarked); 
library(dplyr)
library(ggspatial)  # Para lidar com rasters e mapas
library(sf)# Para geometria vetorial (círculo)
library(plotly)
library(uuid)
library(readxl); library(writexl)
```


## Carrega as funções através do código-fonte

```{r}
carrega <- function(){
source("./source-codes/soma.R")
source("./source-codes/land_create.R")
source("./source-codes/animal_mov.R")
#source("./source-codes/update_mov.R")
source("./source-codes/tracks_viewer.R")
source("./source-codes/estima_testes.R")
source("./source-codes/animal_trajectory.R")  
source("./source-codes/xytoij_transform.R")
source("./source-codes/csv_traj_join.R")  
source("./source-codes/record_trajectories.R")  
}
```


 - Visualização do Raster e propriedades

```{r}
mapa <- raster("./pre-processamento/raster.tif")
lado <- dim(mapa)[1]
extent(mapa) <- extent(0, 1833, 0, 1833)
extent(mapa)
```

## Transformação de coordenadas raster - plano cartesiano

```{r}
delimitar <- extent(0, 1800, 0, 1800)
mapa_delim <- crop(mapa, delimitar)
extent(mapa_delim)
plot(mapa_delim)
```


## Mapeamento de preferências para o algoritmo de movimentação

```{r}
lado_delim <- dim(mapa_delim)[1]
lado_delim*28.66 # lado de 52.5 km
# valores do raster e dicionário
valores_antigos <- sort(unique(getValues(mapa_delim)))
tabela_classes <- biomastats::dict_build()
# filtragem e organização das classes na paisagem
tab_sel <- tabela_classes %>% filter(code %in% valores_antigos) %>%
  arrange(match(code, valores_antigos))
# pesos de habitat e movimentação (paisagem toda)
tab_sel$valores_novos <- c(-10, 10, 8, 8, 4, -3, -8, 1, 1, -10, -5, 2, 1, 7, 1, 3)
source("./source-codes/alterar_valores_raster.R")  
pesos_raster <- alterar_valores_raster(mapa_delim, valores_antigos, tab_sel$valores_novos)  
matrix_pesos <- matrix(getValues(pesos_raster), lado_delim, lado_delim, byrow = TRUE)
```


<!-- ```{r} -->
<!-- # Dimensões da matriz -->
<!-- dim <- 1800 -->

<!-- # Coordenadas do centro da bola -->
<!-- center <- dim / 2 -->

<!-- # Raio da bola -->
<!-- radius <- dim / 4  # Exemplo: define o raio como um quarto do tamanho da matriz -->

<!-- # Inicializa a matriz -->
<!-- matrix <- matrix(-10, nrow = dim, ncol = dim) -->

<!-- # Preenche os valores dentro da bola -->
<!-- for (i in 1:dim) { -->
<!--   for (j in 1:dim) { -->
<!--     # Calcula a distância do centro -->
<!--     distance <- sqrt((i - center)^2 + (j - center)^2) -->

<!--     # Se a distância for menor ou igual ao raio, atribui 10 -->
<!--     if (distance <= radius) { -->
<!--       matrix[i, j] <- 10 -->
<!--     } -->
<!--   } -->
<!-- } -->

<!-- # Visualização (opcional) -->
<!-- #image(matrix, col = c("red", "blue"), main = "Matriz com Bola") -->
<!-- matrix_raster <- raster(matrix, 0, dim, 0, dim) -->
<!-- matrix_pesos <- matrix(getValues(matrix_raster), lado_delim, lado_delim, byrow = TRUE) -->
<!-- plot(raster(matrix_pesos)) -->
<!-- ``` -->

## Forte repulsão nas bordas da matriz

 - fator de redução sugerido = 2



# Redução da dimensionalidade da paisagem

```{r}
M <- matrix_pesos  # M terá dimensão H x W

reduction_factor <- 10

original_H <- dim(M)[1]  # Número de linhas
original_W <- dim(M)[2]  # Número de colunas

# Dimensões reduzidas
new_H <- floor(original_H / reduction_factor)
new_W <- floor(original_W / reduction_factor)

# Matriz reduzida
M_reduc <- matrix(0, nrow = new_H, ncol = new_W)

for (i in seq_len(new_H)) {
  for (j in seq_len(new_W)) {

    # Intervalo de linhas e colunas correspondente ao bloco 10x10
    row_start <- 1 + reduction_factor * (i - 1)
    row_end   <- min(reduction_factor * i, original_H)
    col_start <- 1 + reduction_factor * (j - 1)
    col_end   <- min(reduction_factor * j, original_W)

    bloco <- M[row_start:row_end, col_start:col_end]

    # Exemplo: média (average pooling)
    M_reduc[i, j] <- mean(bloco, na.rm = TRUE)
    # Ou use max(bloco), sum(bloco), etc., dependendo do seu objetivo
  }
}
plot(raster(M_reduc))
```


```{r}
source("./source-codes/matriz_angulo.R")
# Executando a função
#matrix_theta <- get_angle_map(M_reduc, radius=3)
#save(matrix_theta, file = "./pre-processamento/matrix_theta.Rdata")
# Plotar
load("./pre-processamento/matrix_theta.Rdata")
plot(raster(matrix_theta$angle_matrix)*360/(2*pi))
```

# Alterando as bordas da matriz de ângulos

```{r}
nrows <- nrow(matrix_theta$angle_matrix)
ncols <- ncol(matrix_theta$angle_matrix)
# Substituir as três primeiras e últimas linhas
matrix_theta$angle_matrix[1:2, ] <- -pi/2
matrix_theta$angle_matrix[(nrows-2):nrows, ] <- pi/2
# Substituir as três primeiras e últimas colunas
matrix_theta$angle_matrix[, 1:2] <- 0
matrix_theta$angle_matrix[, (ncols-2):ncols] <- -pi
#
# Substituir as três primeiras e últimas linhas
matrix_theta$norm_matrix[1:2, ] <- 0
matrix_theta$norm_matrix[(nrows-2):nrows, ] <- 0
# Substituir as três primeiras e últimas colunas
matrix_theta$norm_matrix[, 1:2] <- 0
matrix_theta$norm_matrix[, (ncols-2):ncols] <- 0
```



# O campo vetorial em espaço reduzido

```{r}
weights_raster <- raster(M_reduc, 0, 1800/reduction_factor, 0, 1800/reduction_factor)
### Verificar se o ângulo está trocado
raster_theta <- raster(matrix_theta$angle_matrix , 0, 1800/reduction_factor, 0, 1800/reduction_factor)
range(matrix_theta$angle_matrix)
extent(raster_theta)
#
nrows <- nrow(raster_theta)
ncols <- ncol(raster_theta)
#
grid_spacing <- max(1, floor(min(nrows, ncols) / 40))
x_coords <- seq(1, ncols, by = grid_spacing)
y_coords <- seq(1, nrows, by = grid_spacing)
#
vector_field <- expand.grid(x = x_coords, y = y_coords)
vector_field$theta <- extract(raster_theta, cbind(vector_field$x, vector_field$y))
vector_field$dx <- cos(vector_field$theta)
vector_field$dy <- sin(vector_field$theta)
vector_field$scale_factor <- extract(raster(matrix_theta$norm_matrix, 0, 1800/reduction_factor, 0, 1800/reduction_factor), cbind(vector_field$x, vector_field$y))
#
# vector_field$scale_factor[ vector_field$scale_factor < 300 ] <- 0
arrow_scale <- 1/50
#
# Aplicar a matriz de escala aos componentes dx e dy
vector_field$dx <- vector_field$dx * vector_field$scale_factor * arrow_scale
vector_field$dy <- vector_field$dy * vector_field$scale_factor * arrow_scale

# Converter o raster para data.frame
raster_df <- as.data.frame(weights_raster, xy = TRUE)
colnames(raster_df) <- c("x", "y", "weights")
raster_df$weights_mod <- raster_df$weights*(raster_df$weights<-10)

# plot
ggplot(vector_field, aes(x = x, y = y))  +
  geom_raster(data = raster_df, aes(x = x, y = y, fill = weights_mod))  +
  scale_fill_gradient(low = "red", high = "white", na.value = "white", name = "Weights") +
  geom_segment(aes(xend = x + dx, yend = y + dy), 
               arrow = arrow(length = unit(0.1, "cm")), color = "black", alpha = 0.8, linewidth = 0.5) +
  theme_minimal() +
  coord_equal() +
  labs(title = "Campo Vetorial do Raster", x = "Colunas", y = "Linhas")
```

```{r}
matrix_theta_reconstituida <- matrix(0, nrow = original_H, ncol = original_W)
matrix_norm_reconstituida <- matrix(0, nrow = original_H, ncol = original_W)

for (i in seq_len(new_H)) {
  for (j in seq_len(new_W)) {
    
    ang <- matrix_theta$angle_matrix[i, j]
    nor <- matrix_theta$norm_matrix[i, j]
    
    row_start <- 1 + reduction_factor * (i - 1)
    row_end   <- min(reduction_factor * i, original_H)
    col_start <- 1 + reduction_factor * (j - 1)
    col_end   <- min(reduction_factor * j, original_W)
    
    matrix_theta_reconstituida[row_start:row_end, col_start:col_end] <- ang
    matrix_norm_reconstituida[row_start:row_end, col_start:col_end] <- nor
  }
}
#plot(raster(matrix_theta_reconstituida,xmn=0, xmx=lado, ymn=0, ymx=lado))
plot(raster(matrix_norm_reconstituida,xmn=0, xmx=lado, ymn=0, ymx=lado))
```

## Convolução dos resultados da matriz theta é necessária, pois senão os ângulos ficam muito parecidos e o animal fica indo e voltando para o mesmo lugar


```{r}
# Criar um kernel para a convolução (exemplo: média 3x3)
#kernel <- matrix(1 / 49, nrow = 7, ncol = 7)  # Kernel de suavização (média)
#set.seed(110401)
ra <- raster(matrix_theta_reconstituida, xmn=0, xmx=lado, ymn=0, ymx=lado)
norm_matrix <- raster(matrix_norm_reconstituida, xmn=0, xmx=lado, ymn=0, ymx=lado)
#ra_blurred <- focal(ra, w = kernel, fun = sum, pad = TRUE, padValue = NA)
plot(norm_matrix)
```

```{r}
carrega()
#ra_blurred
## Colocar um try aqui!!!!
mov <- animal_mov(n = 2, ra = ra, norm_matrix = norm_matrix, time = 4, time_adapt = 0, where = "random", landscape_on = TRUE) 
```

## Gravando as simulações

```{r}
record_trajectories(mov$trajectory)
```

## selecionando as simulações

```{r}
pasta <- "./data_sim/"
sim_res <- csv_traj_join(pasta, 4)
sim_res$selected_files
traj <- sim_res$traj_table
colnames(traj) <- c("id", "step", "week", "x", "y")
traj$id_numeric <- as.numeric(factor(traj$id))
```

## Função de visualização das trajetórias de 1 ou mais indivíduos

```{r}
plot_animal_path <- function(data = traj_obj, animal = c(1,3), weeks = c(1, 2)){

traj_obj <- traj
    
traj_obj <- traj_obj %>% filter(id_numeric %in% animal) %>% filter(week %in% weeks)      

p <- ggplot(traj_obj, aes(x = x, y = y)) +
  geom_path(aes(color = factor(week),  group = interaction(id_numeric, week)), alpha=0.5) + # Usar geom_path para respeitar a ordem dos dados
  scale_color_manual(values = rainbow(length(unique(traj_obj$week)))) + # Definir cores para semanas
  labs(
    title = "Trajectory",
    x = "Coordenada X",
    y = "Coordenada Y",
    color = "Weeks"
  ) +
  theme_minimal() + # Tema limpo
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "right"
  )

print(p)

}
```

## ... 


```{r}
plot(mov$trajectory[[1]][30000:30040,2:3], type = 'l')
```


```{r}
# Para centro
#centro <- mov$trajectory[[1]][1, 2:3]
raio <- 3000 / 28.66
# Para mapa de uso e ocupação
mapa_df <- as.data.frame(mapa_delim, xy = TRUE)
colnames(mapa_df) <- c("x", "y", "value")
dic <- biomastats::dict_build()
valores_unicos <- unique(values(mapa_delim))
valores_unicos <- valores_unicos[!is.na(valores_unicos)]  # Remover NAs, se houver
dd <- data.frame(class = valores_unicos)
dd$class <- as.numeric(as.character(dd$class))
dd$color <- sapply(dd$class, function(x) {
  pos <- which(dic$code == x)
  if (length(pos) > 0) dic$color[pos] else NA
})
paleta_cores <- dd$color
names(paleta_cores) <- dd$class
mapa_df$color <- paleta_cores[as.character(mapa_df$value)]
# Para trajetórias
traj_df <- as.data.frame(traj_stored)
colnames(traj_df) <- c("id", "step", "week", "x", "y")
# Para campo vetorial
nrows <- nrow(ra)
ncols <- ncol(ra)
grid_spacing <- max(1, floor(min(nrows, ncols) / 30))
x_coords <- seq(1, ncols, by = grid_spacing)
y_coords <- seq(1, nrows, by = grid_spacing)
vector_field <- expand.grid(x = x_coords, y = y_coords)
vector_field$theta <- extract(ra, cbind(vector_field$x, vector_field$y))
vector_field$dx <- cos(vector_field$theta)
vector_field$dy <- sin(vector_field$theta)
arrow_scale <- 0.5
vector_field$dx <- vector_field$dx * arrow_scale
vector_field$dy <- vector_field$dy * arrow_scale
# Criar o círculo (como geometria sf)
#circle <- st_as_sf(data.frame(geometry = st_point(centro))) %>%
#st_buffer(dist = raio)
# Plot com ggplot
ggplot() +
  geom_raster(data = mapa_df, aes(x = x, y = y, fill = color), alpha = 0.8) +
  scale_fill_identity() +   
  #geom_segment(data = vector_field, aes(x = x, y = y, xend = x + dx, yend = y + dy), 
  #arrow = arrow(length = unit(0.3, "cm")), color = "red", alpha= 0.8) + 
  geom_path(data = traj_df, aes(x = x, y = y), color = "black", linewidth = 1.2, alpha = 0.7) +
  coord_equal(xlim = c(0, lado), ylim = c(0, lado)) +
  theme_minimal() +
  labs(title = "Centro de Atividade e Home Range",
       x = "Longitude",
       y = "Latitude")
```


<!-- ```{r} -->
<!-- trajectory <- as.data.frame(mov$trajectory[[1]]) -->
<!-- colnames(trajectory) <- c("t","x","y") -->
<!-- dim(trajectory) -->
<!-- trajectory <- trajectory %>% filter(t%%100==0) -->
<!-- # Criar o gráfico com animação -->
<!-- fig <- plot_ly( -->
<!--   data = trajectory, -->
<!--   x = ~x, -->
<!--   y = ~y, -->
<!--   frame = ~t,                      # Variação do tempo -->
<!--   type = 'scatter', -->
<!--   mode = 'markers', -->
<!--   marker = list(size = 8, color = 'blue') -->
<!-- ) %>% -->
<!--   layout( -->
<!--     title = "Trajetória Animada", -->
<!--     xaxis = list(title = "Coordenada X"), -->
<!--     yaxis = list(title = "Coordenada Y"), -->
<!--     showlegend = FALSE -->
<!--   ) -->
<!-- # Mostrar a animação -->
<!-- fig -->
<!-- ``` -->



```{r}
xy_to_ij(500, 1500, 0, 1800, c(1,1))$ij
ra[301 , 501]
plot(mov$trajectory[[1]][t,2:3])
```


